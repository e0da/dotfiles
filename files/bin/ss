#!/usr/bin/env ruby

require 'io/console'

begin
  require 'trollop'
rescue LoadError
  warn <<-EOS
Trollop isn't installed. We need that for argument parsing. Run

  gem install trollop
  EOS
  exit false
end

module ScriptStart

  VERSION = '0.1.1'.freeze

  APM_BUNDLE_PATH  = ENV['APM_BUNDLE'].freeze
  DEFAULT_APPS     = ['property'.freeze].freeze

  PROGRAM_NAME = File.basename($PROGRAM_NAME)

  APM_BUNDLE_ERROR = <<-EOS
You need to export APM_BUNDLE to match your apm_bundle repo location.
e.g. Add this to your ~/.bash_profile

  export APM_BUNDLE=~/src/apm_bundle
  EOS

  USAGE_BANNER = <<-EOS
Manage starting, stopping, and restarting multiple APM apps in concert.

Usage:
        #{PROGRAM_NAME} [OPTIONS] [APP]...

Where [APP]... is any combination of app directory names from apm_bundle/apps.
If omitted, it just manages property. You don't need to be in any particular
directory to run the script.

OPTIONS
  EOS

  def self.run(apps:, force:)
    @apps  = apps
    @force = force
    exit_if_bad_environment
    start_apps
    input_loop
  end

  def self.command_app(app, verb)
    Command.new(app, verb, @force).run
  end

  def self.command_apps(verb)
    @apps.each { |app| command_app app, verb }
  end

  %w[start stop].each do |verb|
    define_singleton_method "#{verb}_apps" do
      command_apps verb
    end

    define_singleton_method "#{verb}_app" do |app|
      command_app app, verb
    end
  end

  def self.restart_app(app)
    stop_app  app
    start_app app
  end

  def self.restart_apps
    @apps.each { |app| restart_app app }
  end

  def self.exit_if_bad_environment
    if APM_BUNDLE_PATH.nil?
      warn APM_BUNDLE_ERROR
      exit false
    end
  end

  def self.input_loop

    loop do
      print_help
      key = STDIN.getch.downcase
      case key
      when 'r'
        restart_apps
      when /\d/
        index = key.to_i - 1
        next if app_index_out_of_bounds? index
        restart_app @apps[index]
      when 'q', 's', "\x03" # \x03 is Ctrl-C
        quit
      end
    end
  end

  def self.app_index_out_of_bounds?(index)
    ![*0...@apps.size].include?(index)
  end

  def self.print_help
    s = multiple_apps? ? 's' : ''
    say '='*40
    if multiple_apps?
      @apps.each_with_index do |app, index|
        say "Press #{index+1} to restart #{app}"
      end
    end
    say "Press r to restart app#{s}"
    say "Press q to stop app#{s} and quit"
    say '='*40
  end

  def self.quit
    stop_apps
    exit true
  end

  def self.multiple_apps?
    @apps.size > 1
  end

  module Say

    DEFAULT = "\033[0m"
    GREEN   = "\033[32m"

    def say(str, color: GREEN)
      puts "#{GREEN}#{str}#{DEFAULT}"
    end
  end
  extend Say

  private

  class Command
    include Say

    COMMAND_TEMPLATE = 'cd %{app_path} && script/%{verb}%{force}'

    def initialize(app, verb, force)
      @app   = app
      @verb  = verb
      @force = force
    end

    def run
      say "Running `#{command}'"
      system command
    end

    private

    def command
      @command ||= COMMAND_TEMPLATE % {app_path: app_path(@app),
                                       verb:     @verb,
                                       force:    force}
    end

    def app_path(app)
      "#{APM_BUNDLE_PATH}/apps/#{app}"
    end

    def force
      ' --force' if @force
    end
  end
end

if __FILE__ == $0

  %w[INT TERM].each do |signal|
    trap(signal) { ScriptStart.quit }
  end

  opts = Trollop::options do
    version ScriptStart::VERSION
    banner ScriptStart::USAGE_BANNER
    opt(:force,
        'Whether to use --force with script/start (applies to all apps)',
        default: false)
  end

  apps = ARGV.empty? ? ['property'] : ARGV

  ScriptStart.run apps: apps, force: opts.force
end
